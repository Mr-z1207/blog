# 第一章 · 绪论

[[TOC]]

## 一、针对考研数据结构的代码书写规范，以及C、C++语言基础

### 1.1、算法设计代码书写规范

举例：将`n (n>1)`个整数存放到一维数组`R`中，将`R`中的循环数列左移`P (0<P<N)`个位置。
> 例如： 将`{1, 2, 3, 4, 5}`左移`2`位，变成`{3, 4, 5, 1, 2}`

:::tip 解析
只需要将`R`中，前`P`个元素逆置，再将剩下的元素逆置，最后将整个`R`逆置即可
:::

```cpp
#include <iostream>
#define N 50
using namespace std;
void Reverse(int R[], int l, int r)
{
    int i,j;
    int temp;
    for(i=l, j=r; i<j; ++i, --j)
    {
        temp = R[i];
        R[i] = R[j];
        R[j] = temp;
    }
}
void RCR(int R[], int n, int p)
{
    if(p<=0 || p>=n)
    {
        cout << "ERROR" << endl;
    }
    else
    {
        Reverse(R, 0, p-1);
        Reverse(R, p, n-1);
        Reverse(R, 0, n-1);
    }
}

int main()
{
    int L, i;
    int R[N], n;
    cin >> L;
    cin >> n;
    for(i=0; i<=n-1; ++i)
    {
        cin >> R[i];
    }
    RCR(R, n, L);
    for(i=0; i<=n-1; ++i)
    {
        cout << R[i] << " ";
    }
    cout << endl;
    return 0;
}
```

以上为一完整程序，但对于答卷来说，显得过于冗长，完全没必要这样书写。其中：
- 第1行和第3行，几乎都要用到，可省略。
- 第2行仅仅定义了一个常量，在用到的时候加个注释就好，可省略
- 第29~46行，是主函数，在答题中，只要写出自己定义的函数，解释好接口就好。

经过以上删减，程序段变为：

``` cpp
void Reverse(int R[], int l, int r)
{
    int i,j;
    int temp;
    for(i=l, j=r; i<j; ++i, --j)
    {
        temp = R[i];
        R[i] = R[j];
        R[j] = temp;
    }
}
void RCR(int R[], int n, int p)
{
    if(p<=0 || p>=n)
    {
        cout << "ERROR" << endl;
    }
    else
    {
        Reverse(R, 0, p-1);
        Reverse(R, p, n-1);
        Reverse(R, 0, n-1);
    }
}
```

再配有部分文字说明就好了。

### 1.2、考研中的C和C++基础

#### 1.2.1、数据类型

- 基本数据类型
  - 整型：int、long、···（考研中涉及整数的题目，无特别要求，用int足以）
  - 字符型：char
  - 浮点型：float、double、···

##### （1）结构型

**结构型为可以理解为用已有数据类型为原料制作的数据类型**例如一个数组，其实就是一个结构型数据变量，例如：
>   ```cpp
>   int a[maxSize]; //maxSize是已定义的常量，表示数组最大长度
>   ```
这将maxSize个整型变量连续的摆在一起，取名为a，如果我们想要制作一个数组，第一个为整型，第二个为字符型，第三个为浮点型，该怎么做呢？
这时我们就用到**结构体了**
``` c
typedef struct
{
    int a;
    char b;
    float c;
}TypeA;
```
这就制造了一个新的数据类型，即TypeA型。就好像`int a`一样，定义一个整型的变量，叫做`a`，那么`TypeA a`一样定义了一个叫做`a`的变量，类型为`TypeA`
结构体与数组的类比可以形象的通过下图表示

![结构体与数组的类比](http://picgo.mr1207.cn/img/408-1-1_1.png)

##### （2）指针型

- 其他变量里装的都是数据元素的内容
- 指针型变量里装的是变量的地址

指针对每种变量都有特定的写法，如下：
``` c
int *a;
char *b;
float *b;
TypeA *d;
```
如果一个指针型变量a`(int *a)`，指向了一个变量j`(int j)`，那么`a`中存放的就是`j`的地址。而`*a`就是取这个地址对应的变量内容，即`*a = j`，`&j`就是获取这个变量的地址，把`j`的地址存放到`a`上就是`a = &j`。

![指针](http://picgo.mr1207.cn/img/408-1-1_2.png)

##### （3）节点的构造

考研中最常见的就是利用**指针**和**结构型**结合起来，构造的**结点**（如链表、二叉树）

1. 链表节点的定义

链表节点有两个域，一个数据域（存放数据），一个指针域（存放下一个节点的地址）。如图所示

![链表节点](http://picgo.mr1207.cn/img/408-1-1_3.png)

```c
typedef struct node
{
    int data;           // 默认int型，可修改； 数据域
    struct node *next;  // 指向node型变量的指针； 指针域
}Node;
```
:::tip
凡是结构型`a`内部有这样相同的指针型`b`，即`b`是用来存放和`a`类型相同的结构体变量地址的指针型，则在定义这个结构体的时候在`typedef struct`后面要加上这个结构体的名字`node`。
:::

2. 二叉树结点的定义

在链表的基础上，再多加一个指针，即二叉树的结构型：
```c
typedef struct BTnode
{
    int data;           // 默认int型，可修改； 数据域
    struct BTnode *Lchild;  // 指向左孩子结点； 指针域
    struct BTnode *Rchild;  // 指向右孩子结点； 指针域
}BTNode;
```

> 在考研中只需熟练掌握以上两种结点。

结构型定义好之后，就要用他制作新结点了。以二叉树为例，有以下两种写法：
```c
// 1
BTNode BT;
// 2
BTNode *BT;
BT = (BTNode *)malloc(sizeof(BTNode)); //此句需熟练掌握
```
- 【2】是考研中用的最多的，执行过程是，先定义一个节点的指针BT，然后用`malloc()`来申请一个节点的内存空间，最后让指针指向这个空间。
- 【2】的BT是个指针变量，指向刚创建的这个结点，但在以后必要的时候，可以离开这个结点，指向其他结点；而【1】中的BT就是这个结点的名称，无法脱离，所以【2】更灵活，也是考研更爱涉及的原因。
- 对于【1】【2】中取分量的表示方式不同，若需要将节点中`data`的值赋给变量`x`，那么：
  - 【1】：`x = BT.data`
  - 【2】：`x = BT->data` 或 `(*BT).data`

##### （4）关于`typedef`和`#define`

1. `typedef`

可以理解为给现有数据类型起一个新名字。例如：
```c
typedef int zhengxing

zhengxing a;  // 就等价于 int a;
```
> 常用在结构体 `typedef struct{···}name;`

2. `#define`

可以理解为定义一个常量，例如：
```c
#define MaxSize 50
#define ERROR 0
#define OK 1
```

#### 1.2.2、函数

##### (1)参数是否改变

首先看如下例子：
```c
int a;

void f(int x)
{
    ++x;
}

int main()
{
    a = 0;
    f(a);

    return 0;
}
```
在执行完这段代码后，变量`a`会是多少呢？可能会有人猜是`1`，其实不然，再调用函数`f()`时把`a`的值赋给了变量`x`，然后在函数内改变了`x`的值，所以`a`的值并不会改变。
如果想让`a`的值发生变化，该如何写呢？

:::tip
注意该方法为C++语法，在C语言中不可用，C语言中靠传入变量地址的方法，麻烦且容易出错，不推荐使用
:::

```cpp
int a;

void f(int &x)
{
    ++x;
}

int main()
{
    a = 0;
    f(a);

    return 0;
}
```
这样相当于`a`取代了`x`，函数`f()`就是对`a`本身进行操作。

> 如果传入的变量是指针型变量，并在函数内部要对传入的指针进行改变，需要写成如下形式
>   ```cpp
>   void f(int *&x)
>   {
>       ++x;
>   }
>   ```
> 具体在树与图的算法中常用，在以后的章节中详解。

## 二、算法的时间复杂度与空间复杂度

### 2.1、考研中的 时间复杂度

将算法中基本操作的执行次数作为算法时间复杂度的度量。常用时间复杂度大小：
> $O(1)<=O(log_2n)<=O(n)<=O(nlog_2n)<=O(n^k)<=O(2^n)$

### 2.2、时间复杂度例题

- 例一：
```c
void fun(int n)
{
    int i = 1, j = 100;
    while(i < n)
    {
        ++j;
        i += 2;
    }
}
```
分析：
第一步找出基本操作，确定规模n
一般来说基本操作只需要看最深层循环就好了，这里就是`++j`和`i += 2`，确定规模，由循环条件`i < n`可知，执行次数与`n`有关，所以问题规模就是`n`。
第二步，计算出`n`的相关函数`f(n)`，显然`i`的初始值为`1`，每次循环后加`2`，所以m次循环后就是$1+2m$，因此当$1+2m=n$时，循环结束，故$m=n/2+1/2$,可得$T(n) = O(n/2+1/2) = O(n)$

- 例二：

```c
void fun(int n)
{
    int i, j, x=0;
    for(i=0; i<n; ++i)
        for(j=i+1; j<n; ++j)
            ++x;
}
```
分析：
计算出 $f(n) = n(n-1)/2$，所以$T(n) = O(n^2)$

- 例三：

```c
void fun(int n)
{
    int i = 0, s = 0;
    while(s < n)
    {
        ++i;
        s = s + i;
    }
}
```
分析：
显然$S1=1$，$S2=1+2$，$S3=1+2+3$···$Sm=m(m+1)/2$，故$n=m(m+1)/2$,解得$T(n) = O(\sqrt{n})$

### 2.3、考研中的 空间复杂度

## 三、数据结构和算法的基本概念

### 3.1、数据结构的基本概念

### 3.2、算法的基本概念

:::warning
未完待续
:::

:::tip
本站所有数据结构相关知识内容，来自本人学习考研时，摘抄、记录自天勤《2021版数据结构高分笔记》，做笔记时难免有马虎的地方，如有错误请联系我修改。
xiaosongsong1207@gmail.com
:::