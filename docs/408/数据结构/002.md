# 第二章 · 线性表

[[TOC]]

## 一、线性表的基本概念与实现

### 1.1、线性表的定义

具有**相同特性**数据元素的一个**有限序列**。该序列中所含元素的**个数**叫做线性表的长度，用`n (n>=0)`表示。
例如：
- 一队学生
  - 人数就是长度，人数有限就是有限序列
  - 身份都是学生，就是数据特性相同
  - 可以是有序的（从高到低），也可以是无序的（随便站）

### 1.2、线性表的逻辑特性

队头的学生前面没人，队尾的学生后面没人，中间的学生前后都有且仅有一个学生，所以线性表除表头表尾都有一个直接前驱和一个直接后继。

### 1.3、线性表的存储结构

线性表的存储结构有两种，一种顺序存储，一种链式存储，前者叫顺序表，后者叫链表。

#### 1.3.1、顺序表

顺序表就是在内存上开辟一块连续的存储空间，将所有元素按照逻辑顺序，依次存放，即，第i个元素后面紧挨着第i+1个元素。

#### 1.3.2、链表

链表不一定紧邻，但是每个节点中除了数据域以外，还包含着一个指针域，存放着后继结点的地址，这样就可以从前驱节点中的地址找到后继结点。

链表有以下5种形式：

##### （1）单链表

每个结点除了数据域外，还包含**一个**指针域，指向后继结点。

![带头结点的单链表](http://picgo.mr1207.cn/img/408-1-2_2.png)

::: details 区分头头结点
- 带头结点的单链表：头指针`head`指向头结点，头结点的数据域不包含任何信息，指针域指向包含数据的开始节点，这样头指针`head`始终不等于`NULL`，当`head->next`等于`NULL`的时候，链表为空。
- 不带头结点的链表：头指针`head`直接指向开始结点，当`head`等于`NULL`的时候，链表为空。
- 注意：做题时要区分头指针和头结点，头指针永远指向**第一个结点**，带头结点的链表，头结点就是第一个结点。
:::

##### （2）双链表

单链表只能从开始结点走向终端结点，无法倒回来。双链表在单链表的基础上添加一个指针域，指向前驱，这样就可以由后继找到前驱。  
同样有两种带头结点和不带头结点。

![带头结点的双链表](http://picgo.mr1207.cn/img/408-1-2_3.png)

##### （3）循环单链表

就是。。终端节点的地址不是`NULL`了，而是指向第一个节点了。。。

![循环单链表](http://picgo.mr1207.cn/img/408-1-2_4.png)

不带头结点的，`head`等于`NULL`，为空表  
带头结点的，`head`等于`head->next`为空

##### （4）循环双链表

就是。。终端节点的`next`指针指向第一个结点，第一个结点的`prior`指针指向终端节点。

![循环双链表](http://picgo.mr1207.cn/img/408-1-2_5.png)

不带头结点的，`head`等于`NULL`，为空表  
带头结点的，`head`等于`head->next`或者`head`等于`head->prior`为空。

##### （5）静态链表

呃...先看图吧。

![静态链表](http://picgo.mr1207.cn/img/408-1-2_6.png)

静态链表，借助一维结构体数组来表示，数组中每个结点除了数据还有一个指针分量，指示了下个结点在数组中的位置（也就是**下标**）
:::tip 注意
这里的指针并不是真正的指针型，而是一个存放数组下标的整型，因其功能与指针相同，故称为指针。
:::

#### 1.3.3 两者差别

顺序表就好像一整块地，每个房间有序的排列着，因此我们只要知道第一个房间的位置，马上可以通过房间号快速找到对应房间——**随机访问特性**；这5个房间的地是整个连续的，且大小不变（6个房间的大小）不管是新建还是拆除，这块地一旦分配就不会改变——**占用连续的储存空间**。  
链表的房间是散落的，靠上一个房间的地址才能找到下一个房间，每次都要从第一个房间往后去找，所以**不支持随机访问**，而且每个房间还要单独留出一块存地址，所以**存储空间利用率稍低**，但是房间不用连续，地皮大小也不固定，可以**动态分配存储空间**。

![两者差别](http://picgo.mr1207.cn/img/408-1-2_1.png)

在顺序表中想要插入一个元素，所有后面的元素都要向后移动，但是链表就不需要，只需要改变地址箭头指向就好。

全面的说：

##### （1）基于空间的比较

1. 存储分配方式不同：顺序表是一次性分配的，链表是动态分配。
2. 存储密度：顺序表 $=1$，链表 $<1$。
   
##### （2）基于时间的比较

1. 存取方式：顺序表随机存取，链表顺序存取
2. 插入/删除 移动的元素个数：顺序表**平均**需要移动进一半的元素，链表不需要移动，只需要改变指针指向。

顺序表插入元素时间复杂度分析：  
具有`n`个元素的顺序表，插入一个元素的平均移动个数。  
（1）求概率  
因为插入位置是随机的，有`n`个位置可以被插入，所以任何一个位置被插入的概率是$P = \frac{1}{n}$  
（2）求期望  
假设插入位置为`i`，那么需要将第`i`个元素之后的元素全部后移一个，也就是移动`n-1`个,所以

$$ E = P\cdot\sum_{i=1}^n(n-i) = \frac{n-1}{2} $$

由此可知，时间复杂度为$O(n)$

## 二、线性表的结构体定义和基本操作

### 2.1、线性表的结构体定义

```c
#define maxSize 100 // 这里定义一个整型常量maxSize，值为100
```

#### 2.1.1、顺序表的结构体定义  
```c
typedef struct
{
  int data[maxSize];   // 存放顺序表元素的数组
  int length;          // 顺序表的长度
}Sqlist;               // 顺序表类型的定义
```  
#### 2.1.2、单链表结点定义  
```c
typedef struct LNode
{
  int data;              // 存放节点的数据域
  struct LNode *next;    // 指向后继的指针节点
}LNode;
```  
#### 2.1.3、双链表结点定义  
```c
typedef struct DLNode
{
  int data;              // 存放节点的数据域
  struct DLNode *prior;  // 指向前驱的指针节点
  struct DLNode *next;   // 指向后继的指针节点
}DLNode;
```  
#### 2.1.4、说明  
结点是内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此我们会在分配链表结点空间的时候，同时定义一个指针，来存储这片空间的地址(这个过程通俗地讲叫指针指向结点)并且常用这个指针的名称来作为结点的名称。  
例如，下边这句代码:
```c
LNode*A=(LNode*)malloc(sizeof(LNode));
```  
用户分配了一片`LNode`型空间，也就是构造了一个`LNode`型的结点，这时候定义一个名字为`A`的指针来指向这个结点，同时我们把也当作这个结点的名字。注意，这里人命名了两个东西:一个是结点，另一个是指向这个结点的指针。  
本书中如果出现此类描述:“`p`指向`q`”，此时指代指针，因为`p`既是指针名又是结点名，但是结点不能指向结点，因此`p`指代指针。又如“用函数`free()`释放`p`的空间”，此时`p`指代结点，因为`p`既是指针名又是结点名，但指针变量自身所需的存储空间是系统分配的，不需要用户调用函数`free()`释放，只有用户分配的存储空间才需要用户自己来释放，所以`p`指代结点。  

### 2.2、顺序表的操作

> 从例题中理解所需知识以及具体的基本操作

例一：  
已知顺序表`L`，其中元素递增有序排列。设计一个算法，插入一个元素`x`，使插入后仍保持递增有序排列（假设插入总能成功）