# 第二章 · 线性表

[[TOC]]

## 一、线性表的基本概念与实现

### 1.1、线性表的定义

具有**相同特性**数据元素的一个**有限序列**。该序列中所含元素的**个数**叫做线性表的长度，用`n (n>=0)`表示。
例如：
- 一队学生
  - 人数就是长度，人数有限就是有限序列
  - 身份都是学生，就是数据特性相同
  - 可以是有序的（从高到低），也可以是无序的（随便站）

### 1.2、线性表的逻辑特性

队头的学生前面没人，队尾的学生后面没人，中间的学生前后都有且仅有一个学生，所以线性表除表头表尾都有一个直接前驱和一个直接后继。

### 1.3、线性表的存储结构

线性表的存储结构有两种，一种顺序存储，一种链式存储，前者叫顺序表，后者叫链表。

#### 1.3.1、顺序表

顺序表就是在内存上开辟一块连续的存储空间，将所有元素按照逻辑顺序，依次存放，即，第i个元素后面紧挨着第i+1个元素。

#### 1.3.2、链表

链表不一定紧邻，但是每个节点中除了数据域以外，还包含着一个指针域，存放着后继结点的地址，这样就可以从前驱节点中的地址找到后继结点。

链表有以下5种形式：

##### （1）单链表

每个结点除了数据域外，还包含**一个**指针域，指向后继结点。

![带头结点的单链表](http://picgo.mr1207.cn/img/408-1-2_2.png)

::: details 区分头头结点
- 带头结点的单链表：头指针`head`指向头结点，头结点的数据域不包含任何信息，指针域指向包含数据的开始节点，这样头指针`head`始终不等于`NULL`，当`head->next`等于`NULL`的时候，链表为空。
- 不带头结点的链表：头指针`head`直接指向开始结点，当`head`等于`NULL`的时候，链表为空。
- 注意：做题时要区分头指针和头结点，头指针永远指向**第一个结点**，带头结点的链表，头结点就是第一个结点。
:::

##### （2）双链表

单链表只能从开始结点走向终端结点，无法倒回来。双链表在单链表的基础上添加一个指针域，指向前驱，这样就可以由后继找到前驱。  
同样有两种带头结点和不带头结点。

![带头结点的双链表](http://picgo.mr1207.cn/img/408-1-2_3.png)

##### （3）循环单链表

就是。。终端节点的地址不是`NULL`了，而是指向第一个节点了。。。

![循环单链表](http://picgo.mr1207.cn/img/408-1-2_4.png)

不带头结点的，`head`等于`NULL`，为空表  
带头结点的，`head`等于`head->next`为空

##### （4）循环双链表

就是。。终端节点的`next`指针指向第一个结点，第一个结点的`prior`指针指向终端节点。

![循环双链表](http://picgo.mr1207.cn/img/408-1-2_5.png)

不带头结点的，`head`等于`NULL`，为空表  
带头结点的，`head`等于`head->next`或者`head`等于`head->prior`为空。

##### （5）静态链表

呃...先看图吧。

![静态链表](http://picgo.mr1207.cn/img/408-1-2_6.png)

静态链表，借助一维结构体数组来表示，数组中每个结点除了数据还有一个指针分量，指示了下个结点在数组中的位置（也就是**下标**）
:::tip 注意
这里的指针并不是真正的指针型，而是一个存放数组下标的整型，因其功能与指针相同，故称为指针。
:::

#### 1.3.3 两者差别

顺序表就好像一整块地，每个房间有序的排列着，因此我们只要知道第一个房间的位置，马上可以通过房间号快速找到对应房间——**随机访问特性**；这5个房间的地是整个连续的，且大小不变（6个房间的大小）不管是新建还是拆除，这块地一旦分配就不会改变——**占用连续的储存空间**。  
链表的房间是散落的，靠上一个房间的地址才能找到下一个房间，每次都要从第一个房间往后去找，所以**不支持随机访问**，而且每个房间还要单独留出一块存地址，所以**存储空间利用率稍低**，但是房间不用连续，地皮大小也不固定，可以**动态分配存储空间**。

![两者差别](http://picgo.mr1207.cn/img/408-1-2_1.png)

在顺序表中想要插入一个元素，所有后面的元素都要向后移动，但是链表就不需要，只需要改变地址箭头指向就好。

全面的说：

##### （1）基于空间的比较

1. 存储分配方式不同：顺序表是一次性分配的，链表是动态分配。
2. 存储密度：顺序表 $=1$，链表 $<1$。
   
##### （2）基于时间的比较

1. 存取方式：顺序表随机存取，链表顺序存取
2. 插入/删除 移动的元素个数：顺序表**平均**需要移动进一半的元素，链表不需要移动，只需要改变指针指向。

顺序表插入元素时间复杂度分析：  
具有`n`个元素的顺序表，插入一个元素的平均移动个数。  
（1）求概率  
因为插入位置是随机的，有`n`个位置可以被插入，所以任何一个位置被插入的概率是$P = \frac{1}{n}$  
（2）求期望  
假设插入位置为`i`，那么需要将第`i`个元素之后的元素全部后移一个，也就是移动`n-1`个,所以

$$ E = P\cdot\sum_{i=1}^n(n-i) = \frac{n-1}{2} $$

由此可知，时间复杂度为$O(n)$

## 二、线性表的结构体定义和基本操作

### 2.1、线性表的结构体定义

```c
#define maxSize 100 // 这里定义一个整型常量maxSize，值为100
```

#### 2.1.1、顺序表的结构体定义  
```c
typedef struct
{
  int data[maxSize];   // 存放顺序表元素的数组
  int length;          // 顺序表的长度
}Sqlist;               // 顺序表类型的定义
```  
#### 2.1.2、单链表结点定义  
```c
typedef struct LNode
{
  int data;              // 存放节点的数据域
  struct LNode *next;    // 指向后继的指针节点
}LNode;
```  
#### 2.1.3、双链表结点定义  
```c
typedef struct DLNode
{
  int data;              // 存放节点的数据域
  struct DLNode *prior;  // 指向前驱的指针节点
  struct DLNode *next;   // 指向后继的指针节点
}DLNode;
```  
#### 2.1.4、说明  
结点是内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此我们会在分配链表结点空间的时候，同时定义一个指针，来存储这片空间的地址(这个过程通俗地讲叫指针指向结点)并且常用这个指针的名称来作为结点的名称。  
例如，下边这句代码:
```c
LNode*A=(LNode*)malloc(sizeof(LNode));
```  
用户分配了一片`LNode`型空间，也就是构造了一个`LNode`型的结点，这时候定义一个名字为`A`的指针来指向这个结点，同时我们把也当作这个结点的名字。注意，这里人命名了两个东西:一个是结点，另一个是指向这个结点的指针。  
本书中如果出现此类描述:“`p`指向`q`”，此时指代指针，因为`p`既是指针名又是结点名，但是结点不能指向结点，因此`p`指代指针。又如“用函数`free()`释放`p`的空间”，此时`p`指代结点，因为`p`既是指针名又是结点名，但指针变量自身所需的存储空间是系统分配的，不需要用户调用函数`free()`释放，只有用户分配的存储空间才需要用户自己来释放，所以`p`指代结点。  

### 2.2、顺序表的操作

> 从例题中理解所需知识以及具体的基本操作

例一：  
已知顺序表`L`，其中元素递增有序排列。设计一个算法，插入一个元素`x`，使插入后仍保持递增有序排列（假设插入总能成功）  
**分析：**  
第一步是找到插入位置，因为顺序表是从小到大排序，找到第一个大于插入元素的元素时，这个元素前面的位置就是插入点。第二步是让插入点之后的所有元素向后移动一个位置，把插入元素放上。  
```cpp
// 返回第一个大于 x 的位置
int findElem(Sqlist L; intx)
{
  int i
  for(i = 0; i < L.length; ++i)
  {
    if(x < L.data[i])  // 对顺序表从小到大循环判断
    {
      return i;       // 返回找到的位置 i
    }
  }
  return i            // 若没有比 x 大的数，说明 x 最大，正好插入到末尾。
}
int insertElem(Sqlist &L, int x)   // 因为L本身需要变化，所以使用引用型
{
  int p, i;
  p = findElem(L, x);              // 调用findElem找到插入点
  if(p < 0 || p > L.length || L.length == maxSize)
  {
    return 0;    // 如果插入点位置小于0或者大于表长，再或者表已满，都返回0，表示插入不成功
  }
  for(i = L.length-1; i >= p; --i)
  {
    L.data[i+1] = L.data[i];   // 循环移动插入点之后的元素
  }
  L.data[p] = x;              // 插入元素
  ++(L.length);    // 表长加一

  return 1;  // 插入成功
}
```  

例二：  
删除顺序表L中下标为p的元素，成功返回1，否则返回0，并将被删除元素赋值给e。  
```cpp
int deleteElem(Sqlist &L, int p, int &e)
{
  int i;
  if(p < 0 || p > L.length-1)
  {
    return 0;
  }
  e = L.data[p];
  for(i = p; i < L.length-1; ++i)
  {
    L.data[i] = L.data[i+1];
  }
  --(L.length);
  return 1;
}
```
- 以上，体现了三个知识点  
  - 按元素值的查找方法  
  - 插入数据元素的方法
  - 删除元素的方法
- 还有两个简单方法需要介绍
  - 初始化顺序表
    ```cpp
    void initList(Sqlist &L)
    {
      // 天勤并没有写这个循环，但是王道有写
      for(int i = 0; i < maxSize; ++i)
      {
        L.data[i] = 0;
      }
      L.length = 0;
    } 
    ```
  - 按位置查找元素
    ```cpp
    int getElem(Sqlist L, int p, int &e)
    {
      if(p < 0 || p > L.length-1)
        return 0;
      e = L.data[p];
      return 1;
    }
    ```

### 2.3、单链表的操作

> 若无特殊说明，链表都是含头结点的链表

例一：  
`A`和`B`为两个链表，其中元素均有序递增，设计一个算法，使`A`和`B`归并为一个非递减有序链表`C`。  
**分析：**  
从AB中挑出最小的放在C的尾巴上，显然AB开头的总是最小的，然后只要比较一下谁更小就好了，如果AB中有一个先全部插入到C了，就把剩下的直接接到C就好了。
```cpp
void merge(LNode *A, LNode *B, LNode *&C)
{
  // 用p、q来跟踪最小节点（开始节点）
  LNode *p = A->next;
  LNode *q = B->next;

  // r始终指向C的终端结点
  LNode *r;

  // 用A的头结点做C的头结点
  C = A;
  C->next = NULL;
  // B的头结点没用了，扔掉
  free(B);

  // 让r指向C，因为C是空的，现在头结点也是终端节点
  r = C;

  // 当p、q都不是空的，选取p、q中较小的结点插入C尾部
  while(p != NULL && q != NULL)
  {
    if(p->data <= q->data)
    {
      r->next = p;
      p = p->next;
      r = r->next;
    }
    else
    {
      r->next = q;
      q = q->next;
      r = r->next;
    }
  }
  r->next = NULL;

  // 将还有剩余结点的链表接在C的尾部
  if(p != NULL)r->next = p;
  if(q != NULL)r->next = q;
}
```
这个例子包含了两个知识点：
- 一是尾插法建立单链表
- 二是单链表的归并操作

将尾插法代码提取出来：  
```cpp
// 假设已经有n个元素存在数组中。
void createlistR(LNode *&C, int a[], int n)
{
  // s用来指向申请的新结点；
  // r用来指向C的终端。
  LNode *s, *r;

  int i;

  // 申请C表的头结点空间
  C = (LNode *)malloc(sizeof(LNode));
  C->next = NULL;

  // r指向C
  r = C;

  // 循环申请n个空间来接收数组a中的元素
  for(i = 0; i < n; ++i)
  {
    s = (LNode *)malloc(sizeof(LNode)); // 申请一个放置数据的空间
    s->data = a[i];  // 新申请的结点接纳a的一个元素
    r->next = s;  // r指向下一个结点
    r = r->next;  // r向后移动一个结点
  }

  // 将终端结点指针域置空。
  r->next = NULL;
}
```  
与之对应的还有头插法：  
```cpp
void createlistF(LNode *&C, int a[], int n)
{
  LNode *s;
  int i;
  C = (LNode *)malloc(sizeof(LNode));
  C->next = NULL;

  for(i = 0; i < n; ++i)
  {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = a[i]
    /* 下面两句是头插法的关键 */
    // 1. s所指新结点的指针域指向C中的开始结点
    s->next = C->next;
    // 2. 头结点的指针域next指向s结点，使得s成为新的开始结点
    C->next = s;
  }
}
```  
:::tip 注意  
1. C结点始终为头结点。  
2. 头插法的顺序与数组顺序相反。  
:::  

单链表的插入操作十分的简单：  
```cpp
s->next = p->next;
p->next = s;
```  
![插入](http://picgo.mr1207.cn/img/408-1-2_7.png)  
:::wrong 注意  
上述插入语句顺序不可以颠倒，如果先`p->next = s;`，那么就会丢失b节点。
:::  
与插入对应的就是删除节点：
```cpp
p->next = p->next->next;
```  
![删除](http://picgo.mr1207.cn/img/408-1-2_8.png)
:::wrong 注意  
考试答卷中还会要求释放被删除节点的内存，所以完整的写法是：
```cpp
q = p->next;
p->next = p->next->next;
free(q);
```  
:::  

例二：  
查找链表C中是否存在值为x的结点，有就删除返回1，无则返回0。  
```cpp
int findAndDelete(LNode *&C, int x)
{
  LNode *p, *q;
  p = C;
  while(p->next != NULL;)
  {
    if(p->next->data = x)
      break;
    p = p->next;
  }

  if(p->next == NULL)
    return 0;
  else
  {
    q = p->next;
    p->next = p->next->next;
    free(p);
    return 1;
  }
}
```
**说明:**  
**以上程序中之所以要使`p`指向所要删除结点的前驱结点，而不是直接指向所要删除结点本身是因为要删除一个结点必须知道其前驱结点的位置，这在之前删除操作的讲解中已经体现。**  
到此为止，考研中对于顺序表和单链表算法操作部分所涉及的最重要的知识点都已经讲解完。考生务必要熟练掌握这些内容。下面要介绍的是双链表、循环链表以及循环双链表的操作。这些内容考研中虽然也会涉及，但常以选择题的形式出现，重要性也不如以上两部分内容，并且这些内容是在上述两部分内容的基础上稍加变动而来的，比较容易理解。

### 2.4、双链表的操作

1. 采用尾插法建立双链表：
   ```cpp
   void createDListR(DLNode *&C, int a[], int n)
   {
     DLNode *r, *s;

     C = (DLNode *)malloc(sizeof(DLNode));
     C->next = NULL;
     C->prior = NULL;

     r = C;

     int i;
     for(i = 0; i < n; ++i)
     {
       s = (DLNode *)malloc(sizeof(DLNode));
       s->data = a[i]

       /* 以上和单链表操作类似 */

       /* 将s插入到C的尾部，并且r指向s，s->prior = r;是和单链表不同的地方 */
       r->next = s;
       s->prior = r;
       r = r->next;
     }
     r->next = NULL;
   }
   ```
2. 查找结点的算法
   ```cpp
   DLNode *findNode(DLNode *C; int x)
   {
     DLNode *p = C->next;

     while(p != NULL)
     {
       if(p->data == x)
         break;
       p = p->next;
     }
     return p;
   }
   ```
3. 插入节点的算法
   ```cpp
   s->next = p->next;
   s->prior = p;
   p->next = s;
   s->next->prior = s;
   ```
4. 删除节点的算法
   ```cpp
   q = p->next;
   p->next = q->next;
   q->next->prior = p;
   free(q);
   ```

### 2.5、逆置问题（重要考点）

可设置两个元素i和j，i指向第一个元素，j指向最后一个元素，边交换两个元素，边互相靠近，相向而行，直至相遇。
```cpp
// 设数组a[n]；
for(int i = 0, j = n; i < j; ++i, --j)
{
  temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}
```

例题：  
数组长度为n，    
1. 将前k个元素逆序后移动到数组后端，其余元素位置无所谓。
2. 将前k个元素移动到数组后端，保持原序，其余元素位置无所谓。
3. 将元素左循p个位置  

**分析：**  
1. 只需逆置整个数组即可；
   ```cpp
   void reverse(int a[], int l, int r, int k)
   {
     int temp;
     for(int i = l, j = r;i < l+k && i < j; ++i, --j)
     {
       temp = a[i];
       a[i] = a[j];
       a[j] = temp;
     }
   }
   ```
2. 先将前k个元素逆置，再逆置整个数组
   ```cpp
   void moveP(int a[], int n, int k)
   {
     reverse(a, 0, k-1, k);
     reverse(a, 0, n-1, k);
   }
   ```
3. 先将前p个元素逆置，再逆置后面的元素，再整个数组逆置
   ```cpp
   void moveP(int a[], int n, int p)
   {
     reverse(a, 0, p-1, p);
     reverse(a, p, n-1, n-p);
     reverse(a, 0, n-1, n);
   }
   ```
